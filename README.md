# 토비의 스프링 3.1
## 토비의 스프링 정리
  - 개인적인 토비의 스프링 저장 공간입니다. 
  - 자세한 사항은 토비의 스프링 3.1을 참고 하시면 감사하겠습니다.

## 1장 오브젝트와 의존관계
### 초난감 DAO
  - 스프링이 가장 관심을 두는 대사은 오브젝트다. 
  - 오브젝트 설계과 구현에 관한 여러가지 응용 기술과 지식이 요구 된다.
    - 객체지향 설계
    - 디자인 패턴 : 다양한 목적을 위해 재활용
    - 리팩토링 : 더 깔끔 한 구조가 되도록 개선 작업
    - 단위테스트 : 오브젝트가 기대한 대로 동작하는지 검증
  - 자바빈
    - 비주얼 툴에서 조작 가능한 컴포넌트. 
    - 디폴트 생성자 : 자바 빈은 파라미터가 없는 디폴터 생성자를 가지고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문
    - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성. set으로 시작하는 수정자 메서드. 
  - JDBC 작업 순서
    - DB연결위한 Connection 가져옴
    - SQL을 담는 Statement를 만듬
    - 만들어진 statement 실행
    - 조회의 경우 SQL쿼리 실행결과를 ResultSet으로 받아 정보 저장할 오브젝트에 옮겨 줌. 
    - 작업 중에 생성된 Connection, Statement, Resultset 등의 리소스를 작업 마친 후 반드시 닫아줌. 
    - 예외를 처리 함. 
  - DAO 클래스가 정상 동작하는지 확인 방법은 웹 애플리케이션을 서버에 배치하고, 웹 브라우저를 통해 DAO 기능을 사용해 보는 것이다. 
    - 배보다 배꼽이 더 큰 일 이 된다. 
  - main()을 이용한 DAO 테스트 코드
    
### DAO의 분리
  - 관심사의 분리
    - 분리와 확장을 고려한 설계로 변경이 일어 났을 때 필요한 작업을 최소화 하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있따. 
    - 관심이 같은 것끼리는 모으고, 관심이 다른것은 따로 떨어져 있게 한다. 
    - '관심사의 분리' : 관심이 같은 것끼리는 하나의 객체 안으로 또는 책한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리.
    - 한가지 관심에 대한 변경이 일어난 경우, 그 관심이 집쭝되는 부분의 소스코드만 수정하면 된다. 
    - 리펙토링의 메서드 추출
        - 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것.
    - 상속을 통해 관심사항을 분리할 수 있다. 
    - 템플릿 메서드 패턴
        - 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메서드나 오버라이딩 가능한 protected 메서드 등으로 만든 뒤 서브 클래스에서 이 메서드를 필요에 맞게 구현해 사용하도록 하는 것. 
    - 팩토리 메서드 패턴
        - 서브 클래스에서 구체적인 오브젝터 생성방법을 결정하게 하는 것. 
  - 상속을 사용한 분리의 문제점
    - 다중상속의 문제가 발생할 수 있다.
    - 상속을 통한 상하위 클래스의 관게가 생각보다 밀접해 진다. 

### DAO의 확장
  - 클래스의 분리(완전히 독립적인 클래스로)
    - 상속으로 클래스를 분리하면 두가지 문제가 발생한다.
        - makeNewConnection이 다른 매서드 명 openConnection()으로 바뀐다면 일일이 다 변경해 줘야 한다. 
        - DB 커넥션을 제공하는 클래스가 어떤 것인지 UserDao가 구체적으로 알고 있어야 한다. 
    - 두 개의 클래스가 서로 긴밀하게 연결되지 않도록 중간에 추상적인 느슨한 연결고리를 만들어 준다. (인터페이스))
        - UserDao 입장에서 어떤 클래스로 ConnectionMaker가 만들어 졌는지 알 필요가 없어진다. 
        - 생성자에서 conntiontionMaker = new DConnectionMaker(); 라는 특정 클래스를 지정하는 문제가 남아있다. 
  - 관계설정 책임의 분리
    - 외부에서 만들어진 오브젝트를 전달받으려면 메서드 파라미터나 생성자 파라미터를 이용하면 된다. 
    - UserDao가 DConnectoinMaker를 알게 해선 안된다. 
    - 객체지향 다형성의 특징으로 코드에서 특정 클래스를 전혀 알지 못하더라도 해당클래스가 구현한 인터페이스를 사용하면 그 클래스의 오브젝트를 인터페이스 타입으로 받을 수 있다. 
    - UserDao 클라이언트는 런타임 오브젝트 관계를 갖는 구조로 만들어 줄 수 있다. 
    - 인터페이스를 도입하고 클라이언트의 도움을 얻은 방법은 상속을 사용했을 떄 보다 유연해졌다. 
  - 원칙과 패턴
    - 클래스나 모듈은 확장에 열려있고 변경에는 닫혀있어야 한다. 
        - 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 개방되 있어야한다.
        - 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 폐쇄 되어 있다.
    - 개방 폐쇄 원칙은 높은 응집도와 낮은 결합도 라는 소프트웨어 개발 원리로 설명 가능하다. 

### 제어의 역전(IoC)
  - 팩토리
    - 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것. 
  - 템플릿 메서드는 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이다. 
    - 프레임 워크는 제어의 역전 개념이 적용되있어야 한다. 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다. 
  - 스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있고, IoC를 극한까지 적용하고 있는 프레임워크다.   

### 스프링 IoC
  - 오브젝트 팩토리를 이용한 스프링 IoC
    - 스프링 빈은 제어의 역전이 적용된 오브젝트를 가리킨다. 
    - 스플이에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리 라고 부른다. 어플케이션 컨텍스트라고 주로 부른다. 스프링 컨테이너라고도 함.
    - @Configuration으로 DaoFactory를 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식하게 하자. 
    - 메서드에는 @Bean을 붙여준다. 
    - 애플리케이션 컨텍스트는 ApplicationContext를 구현한 것이다. 
    - getBean()은 기본적으로 Object 타입으로 리턴하게 되있어 매번 리턴되는 오브젝트에 다시 캐스팅 해줘야 하는 부담이 있다. 
      - 제네릭 메서드 방식을 사용해 두번쨰 파라미터에 리턴 타입을 줌으로 해결 할 수 있다. 
  
  - 애플리케이션 컨텍스트의 동작방식
    - ApplicationContext는 빈 팩토리가 구현하는 BeanFoactory 인터페이스를 상속했으므로 일종의 빈 팩토리인 셈이다. 
    - DaoFactory를 오브젝트 팩토리로 직접 사용했을 떄 비해 애플리케이션 컨텍스트를 사용했을 때 얻는장점
      - 클라이언트는 구첵적인 팩토리 클래스를 알 필요가 없다. 
      - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해 준다. 
      - 빈을 검색하는 다양한 방법을 제공한다. 

  - 스프링 IoC의 용어 정러
    - 빈 : 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻.스프링이 직접 그 생성과 제어를 담당하는 오브젝트만 빈이라고 부른다..
    - 빈 팩토리 : 스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 관리함. BeanFactory를 확장한 애플리케이션 컨텍스트를 주로 이용한다. 
    - 애플리케이션 컨텍스트 : 빈 팩토리를 확장한 IoC 컨테이너. 스프링이 제공하는 각종 부가 서비스를 추가로 제공함. 
    - 설정정보 / 설정 메타정보 : 애플리케이션 켄텍스트 또는 빈팩토리가 IoC를 적용하기 위해 사용하는 메타 정보. configuration.
    - 컨테이너 or IoC 컨테이너 : IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 한다. 
    - 스프링 프레임워크 : 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용. 줄여서 스프링 이라고 말하기도 함.

### 싱글톤 레지스트리와 오브젝트 스코프
  - 스프링은 여러번 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다. 
  - 싱글톤 레지스터리로서의 애플리케이션 컨텍스트
    - 매번 새로 만들게 되면 수많은 요청이 오게 된다면 부학 발생한다. 
    - 서블릿은 서비스 오브젝트 기술중 하나인데, 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 
    - 서버 환경에서 싱글톤의 사용이 권장된다. 
    - 싱글톤 구현의 문제점
      - private 생성자라 상속할 수 없다. 객체지향적인 장점이 없어진다. 
      - 테스트 하기 어렵다. 
      - 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. 
      - 싱글콘의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다. 
    - 싱글톤 레지스트리
      - 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 바로 싱글톤 레지스트리라 부른다. 
      - public한 생성자를 가질 수 있다. 
      - 테스트 환경에서도 자유롭다. 
      - 스프링은 IoC 컨테이너일 뿐만아니라 싱글톤 레지스트리 이다. 
  - 싱글톤 오브젝트의 상태
    - 싱글톤은 동시접근이 가능해 상태 관리에 주의해야한다. 
    - 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 생태유지 방식으로 만들지 않는다. 
    - 파라미터와 로컬변수, 리턴 값등을 이용해 리소스로부터 생성한 정보를 다룰 수 있다. 
    - 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 좋다. 

### 의존관계 주입(DI)
  - 제어의 역전과 의존성 관계 주입
    - DI는 오브젝트 레퍼런스를 외부로부터 제공받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관게를 만드는 것이 핵심이다. 
  - 런타임 의존관계 설정
    - 두 클래스 또는 모듈이 의존관계 있다고 할때 항상 방향성을 부여해 줘야 한다. 
    - A --> B 있을때 B가 변하면 그것이 A에 영향을 미친다는 의미이다. 
    - 인터페이스에 대해서만 의존관계를 만들어 주면 인터페이스를 구현한 클래스와의 관계는 느슨해져 결합도가 낮아지게 된다. (모델링 의존관계 시점)
    - 의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시 연결해 주는 작업을 말한다. 
    - DAOFactory는 런타임 시점에 UserDao가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고, 이를 생성 후 의존 관계를 맺는다. 
  - 의존관계 검색과 주입
    - 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 
    - getBean()으로 의존관계 검색에 사용된다. 
    - 의존관계 검색 보다는 의존관계 주입 방식을 사용하는 편이 더 낫다. 
    - 의존관계 검색이 필요한 시점은 애플리케이션 기동 시점에 적어도 한번 사용해야 한다. 스태틱 메서드인 main()에서 DI를 이용해 오브젝트를 주입 받는 방법이 없기 때문에이다.
    - 의존 관계 검색 방식에선 검색하는 오브젝트는 자신이 스프링 빈일 필요가 없다. 
    - 의존관계주입(DI)는 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다. 
      - 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입의 파라미터를 통해 이뤄져야 한다. 
  - 의존관계 주입의 응용
    - 개발환경과 운영환경에서 DI의 설정정보에 해당하는 DaoFactory만 다르게 만들어 두면 나머지 코드엔 손대지 않고 개발 시와 운영 시 각각 다른 런타임 오브젝트에 의존관계를 가지게 할 수 있다. 
  - 메서드를 이용한 의존관계 주입
    - 수정자 메서드를 이용한 주입
      - 외부에서 오브젝트 내으의 애프리뷰트 값을 변경하려는 용도로 주로 사용된다. 
      - 메서드는 set으로 시작. 
    - 일반 메서드를 이용한 주입
      - set으로 시작해야 하고 여러개의 파라미터를 갖을 수도 있다. 
    - 스프링은 메서드를 이용한 DI 방법중 수정자 메서드를 가장 많이 사용해 왔다. 

### DataSource 인터페이스로 변환
  - 자바에는 DataSource 라는 인터페이스가 존재한다. 
  - 일반적으론 DataSource를 구현해 DB커넥션을 제공하는 클래스를 만들 일은 거의 없다. 다양한 DB연결과 풀링 기능을 갖춘 많은 DataSource 구현 클래스가 존재하기 때문.
  - DataSource에서 고나심을 가질 것은 getConnection() 메서드 하나 뿐이다. 

## 2장 테스트
### UserDaoTest 다시보기
  - 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 확인해, 만든코드를 확신할 수 있게 해주는 작업이다. 
  - 작은 단위의 테스트(=단위테스트)
    - 테스트 하고자 하는 대상이 명확하다면 그 대상에만 집중해 테스트 하는것이 바람직하다. 
    - 관심이 다르면 테스트할 대상을 분리하고 집중해 접근해야 한다. 
    - 단위테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자가 스스로 빨리 확인받기 위해서다. 
    - 자동수행 테스트 코드
      - 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 
    - 지속적인 개션과 점진적인 개발을 위한 테스트
  - UserDaoTest의 문제점
    - 수동 확인 작업의 번거로움
      - 콘솔을 직접 눈으로 확인해서 정상인지 봐야 하는 불편함이 있다. 
    - 실행 작업의 번거로움

### UserDaoTest 개선
  - 테스트의 효율적인 수행과 결과 관리
    - JUnit은 자바 개발의 유명한 테스트 지원 도구이다. 
    - 테스트가 main() 메서드로 만들어 지면 제어권을 직접 갖는 의미이기 땜에 프레임 워크에 적용하기에 적합하지 않다. 
    - JUnit 프레임워크의 요구 조건 2가지
      - 메서드가 public 으로 선언되야 한다.
      - 메서드에 @Test 애노테이션을 붙여야한다. 
    - main()에서 사용한 if 문을 JUnit이 제공해 주는 assertThat 스태틱 메서드를 이용해 변경할 수 있다. 
    - is()는 매처의 일종으로 equals()로 비교해주는 기능을 가졋다. 
    - 스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다. 
    - JUnit은 assertThay()을 이용해 검증했을 때 기대한 결과가 아니면 AssertionError를 던진다. 

### 개발자를 위한 테스팅 프레임워크 JUnit
  - 스프링 테스트 모듈로 JUnit을 이용한다. 
  - JUnit 테스트 실행방법
    - 가장 좋은 실행 방법은 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다. 
    - manin()을 만들지 않아도 된다. 
    - 빌드 툴
      - 여러 개발자가 만든 코드를 모두 통합해 테스트를 수행해야 할 경우 서버의 모든 코드를 가져와 통합하고 빌드한 뒤 테스트를 수행하는게 좋다. 
  - 테스트 결과의 일관성
    - 코드에 변경사항이 없다면 단위 테스트는 항상 동일한 결과를 내야 한다. 외부 상태에 따라 변하면 안됨.(일관성 보장)
  - 포괄적인 테스트
    - 테스트 메서드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.
    - 자바 빈의 규약을 따르는 클래스에 생성자를 명시적으로 추가했을 경우 파라미터가 없는 디폴트 생성자도 함께 정의해 줘야한다.
    - JUnit은 특정한 테스트 메서드 실행순서를 보장해 주지 않는다( * JUnit 4.11 부터는 순서가 정해짐. 디폴트가 해시값으로 순서정함.)
    - 테스트 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 
  - get() 예외조건에 대한 테스트
    - 일반적으로 테스트 중 예외가 던져지면 테스트 메서드의 실행은 중단되고 테스트는 실패한다. 
    - 예외발생 여부는 assertThat() 메서드로 검증이 불가능 하다. 
    - JUnit에서 예외 조건 테스트를 위한 방법을 제공해준다. 
      > @Test(expected=EmptyResultDataAccessException.class)
    - expected에 테스트 메서드 실행 중 발생하리라 기대하는 예외 클래스를 넣어주면 된다. 
    - 포괄적인 테스트
      - 테스트를 만들때 성공만 하는 케이스를 만들지 말고, 부정적인 케이스를 먼저 만드는 습관을 들이는게 좋다. 
      - get()의 경우 존재하는 id를 조회하는 기능도 중요하지만 존재하지 않은 id가 주어졌을 때 어떻게 반응할지를 결정하고 이를 확인할 수 있는 테스트를 먼저 만들어야 예외적 상황을 빠뜨리지 않는다. 
  - 테스트가 이끄는 개발
    - 기능 설계를 위한 테스트
      - 보통 기능 설계, 구현, 테스트의 개발 흐름에서 기능설계에 해당하는 부분을 테스트 코드가 일부 담당할 수 있다. 
      - 추가 하고 싶은 기능을 일반 언어가 아닌 테스트 코드로 표현해서, 마치 코드로 된 설계문서처럼 만들어 놓을 수 잇다. 
    - 테스트 주도 개발
      - TDD라고 하는데 만들고자 하는 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이다. 
      - 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 기본 원칙이다. 
      - 테스트를 먼저 작성하기 때문에 테스트를 뺴먹지 않고 꼼꼼히 만들 수 있다. 
      - 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다. 
      - 테스트 코드를 작성한 후 가능한 빨리 실행할 수 있어야 한다. 
    - 테스트 코드의 개선
      - 테스트 코드도 리펙토링 가능하다. 
      - JUnit 프레임워크는 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메서드에 넣게 해주고, 이를 매번 테스트 메서드 실행하기 전에 먼저 실행시켜주는 기능이 있다. 
        - @Before
      - JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식
        - 테스트 클래스에서 @Test가 붙은 public 이고 void 형이며 파라미터가 없는 테스트 메서드를 모두 찾는다. 
        - 트스트 클래스의 오브젝트를 하나 만든다.
        - @Before가 붙은 메서드가 있으면 실행한다. 
        - @Test가 붙은 메서드 하나 호출하고 테스트 결과를 저장해 둔다. 
        - @After가 붙은 메서드가 있으면 실행한다. 
        - 나머지 테스트 메서드에 대해 2~5번 반복한다.
        - 모든 테스트의 결과를 종합해 돌려준다. 
      - 테스트 클래스 안에 트스트 메서드들은 공통적인 준비 작업과 정리 작업이 필요한 경우가 있는데, @Befor, @After로 처리한다. 
      - 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 한다. 
      - 테스트 메서드를 실행할 떄마다 테스트 클래스의 오브젝트를 새로 만든다. 
    - 픽스처
      - 테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다. 
      - 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메서드를 이용해 생성해 두면 편리하다. 

### 스프링 테스트 적용
  - 애플리 케이션커넥스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화 한다. 
  - 테스트는 가능한 독립적으로 매번 새로운 오브젝트를 만들어 사용하는 것이 원칙이다.
  - 하지만 애플리케이셔녀 컨텍스트처럼 생성에 많은 시간과 자원을 소모되는 경우 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 
  - 빈은 싱글톤으로 만들어졌기 때문에 상태를 갖지 않는다. 
  - 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일이 거의 없어 한번만 만들고 여러 테스트가 공유해서 사용해도 된다. 
  - JUnit은 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 @BeforeClass 스태틱 메서드를 지원한다. 
    - 스태틱 변수에 저장해 두고 테스트 메서드에서 사용하게 할 수 있다. 
    - 하지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는것이 더 편리하다. 
  - 테스트를 위한 애플리케이션 컨텍스트 관리
    - 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 
    >   @RunWith(SpringJUnit4ClassRunner.class) 
    >   @ContextConfiguration(classes = {DaoFactory.class} )  // java config 이용방법. xml은 location="/applicaionContext.xml"로 바꿔치기하면 된다.
    - SpringJUnit4ClassRunner 라는 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중 테스트가 사용할 애플리케이션 컨텍스트를 만들과 관리한다. 
    - @ContextConfiguration은 자동으로 만들어 줄 애플리케이션 컨텍스트 설정파일 위치를 지정하는 것이다. 
  - 테스트 클래스의 컨텍스트 공유
    - 여러 개의 테스트 클래스가 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스들 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다. 
    - 스프링은 설정파일의 종류만큼 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트에서는 이를 공유하게 해준다. 
  - @Autowired
    - 스프링 DI에 사용되는 특별한 애노테이션이다. 
    - @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾고 있으면 주입해준다. 
    - 생성자나 수정자 메서드 없이도 가능하다. 
    - 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 
    - 구지 getBean()을 사용하는 것이 아니라 직접 DI 받을수 있게 된다. 
    - @Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다. 
    - 같은 타입의 빈이 두 개 이상 있는 경우 타입으로만 어떤 빈을 가져올지 결정할 수 없다. 예외 발생. 
    - 테스트 코드에서도 가능한 한 인터페이스를 사용해 애플리케이션 코드와 느슨하게 연결해 두는 편이 좋다. 
  - DI와 테스트
    - 테스트할 대상의 범위가 넓어지면 테스트를 작성하기가 어려워진다. 그래서 인터페이스를 두고 DI를 적용하자. 
    - 테스트 코드에 의한 DI
      - DI는 스프링 컨테이너에서만 할 수 있는 작업이 아니다. 수정자 메서드로도 가능하다. 
      - 테스트 코드에 의한 DI를 이용해 테스트 중 DAO가 사용할 DataSource 오브젝트를 바꿔주는 방법이 있다. (테스트용, 운영용 DB연결)
      - 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙이다. 
    - 테스트를 위한 별도의 DI 설정
      - 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어 두는 방법이 있다. 
      - 두 가지 설정 파일을 만들어 하나는 서버 운영용 DataSource를 빈으로 등록해두고, 다른 하나에는 테스트에 적합한 DataSource를 빈으로 만드는 것이다. 
    - 컨테이너 없는 DI 테스트
      - 테스트 코드에 직접 오브젝트를 만들고 DI해서 사용해도 된다. 
      - 테스트 할 떄 마다 매번 새로운 오브젝트가 만들어지는 단점은 있다. 
      - DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도룸을 쭐 뿐 반드시 필요한 것은 아니다. 
    - DI를 이용한 테스트 방법 선택
      - 항상 스프링 컨테이너 없이 테스트 할 수 있는 방법을 가장 우선으로 고려하자. 
        - 테스트 수행 속도가 빠르고 테스트가 간결해진다. 
      - 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우 스프링의 설정을 이용한 DI방식의 테스트를 이용하면 편리하다. 
      - 테스트에서 애플리케이션 컨텍스트를 사용하는 경우 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다. 
        - 개발환경, 테스트환경, 운영환경 차이가 있기 때문에 각각 다른 설정파일을 만들어 사용하는게 일반적이다. 

### 학습 테스트로 배우는 스프링
  - 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들ㄹ어 제공한 라이브러리 등을 테스트 해야 하는데 이를 학습 테스트라 한다. 
  - 학습 테스트의 목적은 자신이 사용할 API나 프레임워크 기능을 테스트 해봄으로 사용 방법을 익히려는 것이다. 
  - 학습 테스트의 장점
    - 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다. 
      - 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는 지 빠르게 확인할 수 있다. 
    - 학습 테스트 코드를 개발 중에 참고할 수 있다. 
      - 수동으로 예제를 만드는 방법은 결국 최종 수정한 예제 코드만 남아 있는 반면, 테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고 남겨둘 수 있다.
    - 프레임워크나 제품을 업그레이드 할 때 호환성 검증을 도와준다.
      - 업그레이드가 있을 떄 기존에 사용했던 API나 기능에 변화가 있거나 업데이트 된 제품에 버그가 있다면 학습 테스트를 통해 미리 확인할 수 있따. 
    - 테스트 작성에 좋은 훈련이 된다. 
  - 스프링 레퍼런스 매뉴얼이나 관련 서적을 가지고 공부하면서 설명이 이해 안갈 때 직접 학습 테스트로 만들어 보면 도움이 된다. 
  - 스프링 학습 테스트 참고용으로 가장 좋은 소스는 스프링 자신에 대한 테스트 코드이다. 스프링 배포판 압축을 풀어보면 프레임워크 소스와 함꼐 테스트 코드가 있다. 
  - 학습 테스트 예제
    - assertThay()의 not()은 뒤에 나오는 결과를 부정하는 매처다. 즉 같지 않아야 성공한다. 
    -  검증로직을 코드로 만드는 방법
      - assertThat()을 이용하는 것. 






